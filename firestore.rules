/**
 * @fileoverview Firestore Security Rules for the AI News Access application.
 *
 * @description
 * This ruleset enforces a security model centered around user data privacy,
 * role-based administrative access, and secure collaboration. It uses a combination
 * of path-based ownership, denormalized authorization data, and role checks to
 * ensure users can only access data they are explicitly permitted to.
 *
 * Core Philosophy:
 * The primary security posture is "deny by default." Access is granted explicitly
 * based on user ownership or administrative roles. User data is strictly private,

 * accessible only by the owner and administrators.
 *
 * Data Structure:
 * - /users/{userId}: Private user profile documents.
 * - /school_club/{clubId}/members/{userId}: Membership records, readable by the
 *   member but managed by administrators.
 * - /messages/{conversationId}: Conversation metadata, including participant lists,
 *   which governs access to the messages subcollection.
 * - /messages/{conversationId}/messages/{messageId}: Individual messages within a
 *   conversation, accessible only by participants.
 * - /users/{userId}/notifications/{notificationId}: A user-specific subcollection
 *   for notifications, ensuring strict data isolation.
 *
 * Key Security Decisions:
 * - User Listing: Listing the `/users` collection is prohibited for non-administrators
 *   to protect user privacy.
 * - Admin Access: A user with an 'admin' role has read and write access to most
 *   data for moderation and management purposes.
 * - Collaborative Data: Access to conversations and messages is controlled by a
 *   denormalized `participantIds` array on the parent conversation document.
 *   This avoids costly and insecure cross-collection queries in rules.
 * - Denormalization for Authorization: Critical authorization data (like user roles
 *   and conversation participants) is stored directly on the relevant documents to
 *   create simple, fast, and secure rules.
 * - Structural Segregation: User-specific data like notifications is structured as
 *   a subcollection under the user's document (`/users/{userId}/notifications`) to
 *   leverage path-based security and simplify rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the authenticated user has an 'admin' role.
     * This requires a read to the user's own profile document.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * Checks if a document exists for update/delete operations.
     */
    function docExists() {
      return resource != null;
    }
    
    /**
     * Checks if the requester is the owner of an existing document.
     * Used for secure update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && docExists();
    }
    
    /**
     * Checks if the requester is an admin acting on an existing document.
     * Used for secure update and delete operations by administrators.
     */
    function isExistingAdmin() {
      return isAdmin() && docExists();
    }

    /**
     * Validates required relational fields on user document creation.
     * Ensures the document ID matches the user's auth UID and prevents
     * self-assigning the admin role.
     */
    function hasValidUserCreateData(userId) {
      let data = request.resource.data;
      return data.id == userId
             && data.role != 'admin';
    }
    
    /**
     * Validates immutability of critical user fields on update.
     * Prevents changing the document ID. Also prevents a user from
     * elevating their own role.
     */
    function hasValidUserUpdateData() {
      let data = request.resource.data;
      return data.id == resource.data.id
             && (isAdmin() || data.role == resource.data.role);
    }
    
    /**
     * Checks if the authenticated user is a participant in a conversation.
     * This requires reading the parent conversation document.
     */
    function isParticipant(conversationId) {
      let conversation = get(/databases/$(database)/documents/messages/$(conversationId));
      return isSignedIn() && request.auth.uid in conversation.data.participantIds;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (get) A user reads their own profile: `get /users/user_abc` (auth.uid: 'user_abc').
     * @allow (create) A new user creates their own profile document: `create /users/user_xyz` (auth.uid: 'user_xyz').
     * @deny (list) A regular user attempts to list all users: `list /users` (auth.uid: 'user_abc').
     * @deny (update) A user tries to change another user's profile: `update /users/user_xyz` (auth.uid: 'user_abc').
     * @principle Restricts access to a user's own data tree and grants admins privileged access.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && hasValidUserCreateData(userId);
      allow update: if (isExistingOwner(userId) || isExistingAdmin()) && hasValidUserUpdateData();
      allow delete: if isExistingOwner(userId) || isExistingAdmin();
    }

    /**
     * @description Stores membership information for school clubs.
     * @path /school_club/{clubId}/members/{userId}
     * @allow (get) A user reads their own club membership details: `get /school_club/club_123/members/user_abc` (auth.uid: 'user_abc').
     * @allow (create) An admin creates a membership for a user: `create /school_club/club_123/members/user_abc` (auth.uid: 'admin_user').
     * @deny (create) A regular user tries to create their own membership: `create /school_club/club_123/members/user_abc` (auth.uid: 'user_abc').
     * @deny (list) A regular user tries to list all members of a club: `list /school_club/club_123/members`.
     * @principle Enforces admin-only management for sensitive membership data while allowing members to read their own status.
     */
    match /school_club/{clubId}/members/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() && request.resource.data.userId == userId && request.resource.data.clubId == clubId;
      allow update: if isExistingAdmin() && request.resource.data.userId == resource.data.userId && request.resource.data.clubId == resource.data.clubId;
      allow delete: if isExistingAdmin();
    }
    
    /**
     * @description Manages conversation documents, which act as the authorization anchor for messages.
     * @path /messages/{conversationId}
     * @allow (get) A participant reads conversation metadata: `get /messages/convo_123` (auth.uid is in participantIds).
     * @allow (create) A user starts a new conversation including themselves: `create /messages/convo_456` (auth.uid is in participantIds).
     * @deny (update) A user tries to modify the participant list: `update /messages/convo_123`.
     * @deny (list) A user tries to discover all conversations: `list /messages`.
     * @principle Access is granted based on a denormalized list of participants, avoiding cross-collection lookups.
     */
    match /messages/{conversationId} {
      allow get: if isParticipant(conversationId);
      allow list: if false; // Disallow listing all conversations for security
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      allow update: if false; // For prototyping, updates are disabled. Define clear rules for adding/removing users later.
      allow delete: if false; // For prototyping, deletes are disabled. Define who can delete a conversation later.

      /**
       * @description Stores individual messages within a conversation.
       * @path /messages/{conversationId}/messages/{messageId}
       * @allow (list) A participant lists the messages in a conversation: `list /messages/convo_123/messages` (auth.uid is in convo_123's participantIds).
       * @allow (create) A participant sends a new message: `create /messages/convo_123/messages/msg_abc` (auth.uid is a participant).
       * @deny (get) A non-participant tries to read a message: `get /messages/convo_123/messages/msg_abc` (auth.uid is NOT a participant).
       * @deny (update) A user tries to edit another user's message: `update /messages/convo_123/messages/msg_abc` (auth.uid != senderId).
       * @principle Subcollection access is secured by checking the parent document's authorization data (`participantIds`).
       */
      match /messages/{messageId} {
        allow get, list: if isParticipant(conversationId);
        allow create: if isParticipant(conversationId) && request.resource.data.senderId == request.auth.uid && request.resource.data.conversationId == conversationId;
        allow update: if docExists() && isParticipant(conversationId) && isOwner(resource.data.senderId) && request.resource.data.senderId == resource.data.senderId;
        allow delete: if docExists() && isParticipant(conversationId) && isOwner(resource.data.senderId);
      }
    }
    
    /**
     * NOTE: The provided data structure for notifications at `/notifications/{userId}` is not scalable,
     * as it implies one document per user. This has been implemented as a standard user-owned subcollection
     * at `/users/{userId}/notifications/{notificationId}` to correctly support multiple notifications per user.
     */
    
    /**
     * @description Stores user-specific notifications.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (get) A user reads their own notification: `get /users/user_abc/notifications/notif_123` (auth.uid: 'user_abc').
     * @allow (list) A user lists all of their notifications: `list /users/user_abc/notifications`.
     * @deny (get) A user tries to read another user's notification: `get /users/user_xyz/notifications/notif_456` (auth.uid: 'user_abc').
     * @deny (create) A user tries to create a notification for someone else: `create /users/user_xyz/notifications/notif_789` (auth.uid: 'user_abc').
     * @principle Enforces strict ownership by placing user-private data in a subcollection under their own document.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }
  }
}